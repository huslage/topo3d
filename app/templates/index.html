<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topo3D - Topographical 3D Model Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            height: calc(100vh - 200px);
        }

        .sidebar {
            background: white;
            border-radius: 12px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .viewer-container {
            background: #1a1a1a;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .section:last-child {
            border-bottom: none;
        }

        .section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .file-upload {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-upload input[type="file"] {
            display: none;
        }

        .file-upload-label {
            display: block;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
            font-weight: 500;
        }

        .file-upload-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .file-name {
            margin-top: 8px;
            font-size: 0.9em;
            color: #666;
            font-style: italic;
        }

        input[type="text"], input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 0.95em;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .checkbox-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .checkbox-item label {
            cursor: pointer;
            user-select: none;
        }

        button {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        button.success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .object-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
        }

        .object-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: #f5f5f5;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .object-item:hover {
            background: #e0e0e0;
        }

        .object-item.selected {
            background: #667eea;
            color: white;
        }

        .object-item button {
            padding: 4px 12px;
            font-size: 0.85em;
            margin: 0;
            width: auto;
        }

        .status {
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .status-floating {
            position: absolute;
            top: 12px;
            left: 12px;
            right: 12px;
            z-index: 50;
            box-shadow: 0 8px 18px rgba(0,0,0,0.2);
            border: 1px solid rgba(0,0,0,0.08);
            background: #fff;
            display: none;
            white-space: pre-line;
            pointer-events: none;
        }

        .render-debug {
            position: absolute;
            right: 12px;
            bottom: 12px;
            z-index: 45;
            min-width: 280px;
            max-width: 460px;
            padding: 10px 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.72);
            border: 1px solid rgba(255,255,255,0.15);
            color: #c7ffd4;
            font-size: 12px;
            line-height: 1.4;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            white-space: pre-line;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #d32f2f;
        }

        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
            z-index: 1000;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .controls-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 0.9em;
        }

        .controls-overlay h4 {
            margin-bottom: 8px;
        }

        .controls-overlay p {
            margin: 4px 0;
        }

        .label-input-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .label-input-group input {
            flex: 1;
        }

        .label-input-group button {
            width: auto;
            margin: 0;
            padding: 10px 20px;
        }

        .slider-group {
            margin: 15px 0;
        }

        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #666;
        }

        .slider-group input[type="range"] {
            width: 100%;
        }

        .slider-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: 600;
            color: #667eea;
        }

        /* Color Picker Modal */
        .color-picker-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .color-picker-modal.active {
            display: flex;
        }

        .color-picker-content {
            background: white;
            border-radius: 12px;
            padding: 25px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .color-picker-content h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .color-picker-content p {
            color: #666;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .color-input-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .color-input-group input[type="color"] {
            width: 80px;
            height: 50px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
        }

        .color-input-group input[type="text"] {
            flex: 1;
        }

        .color-picker-actions {
            display: flex;
            gap: 10px;
        }

        .color-picker-actions button {
            margin-top: 0;
        }

        .building-color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üèîÔ∏è Topo3D</h1>
            <p>Create 3D Printable Topographical Models</p>
        </header>

        <div class="main-grid">
            <!-- Sidebar -->
            <div class="sidebar">
                <!-- File Upload -->
                <div class="section">
                    <h3>üìÅ Upload GPX File</h3>
                    <div class="file-upload">
                        <input type="file" id="gpx-file" accept=".gpx">
                        <label for="gpx-file" class="file-upload-label">Choose GPX File</label>
                        <div class="file-name" id="file-name">No file selected</div>
                    </div>
                </div>

                <!-- Address Input -->
                <div class="section">
                    <h3>üìç Highlight Address</h3>
                    <input type="text" id="address-input" placeholder="Paste Google Maps URL or enter address">
                    <button id="geocode-btn" onclick="geocodeAddress()">Find Location</button>
                    <div class="checkbox-item" style="margin-top: 10px;">
                        <input type="checkbox" id="show-only-address-building" disabled>
                        <label for="show-only-address-building">Show only address building (red)</label>
                    </div>
                    <p id="address-status" style="font-size: 0.85em; color: #666; margin-top: 5px;"></p>
                </div>

                <!-- Map Features (Cesium buildings + terrain sampling) -->

                <!-- Model Options -->
                <div class="section">
                    <h3>‚öôÔ∏è Model Options</h3>
                    <div class="slider-group">
                        <label>
                            Vertical Scale: <span class="slider-value" id="vertical-scale-value">1.0</span>x
                        </label>
                        <input type="range" id="vertical-scale" min="0.5" max="3" step="0.1" value="1.0" oninput="updateSliderValue('vertical-scale')">
                    </div>
                    <div class="slider-group">
                        <label>
                            Model Width: <span class="slider-value" id="model-width-value">200</span>mm
                        </label>
                        <input type="range" id="model-width" min="50" max="500" step="10" value="200" oninput="updateSliderValue('model-width')">
                    </div>
                    <div class="slider-group">
                        <label>
                            Base Height: <span class="slider-value" id="base-height-value">10</span>mm
                        </label>
                        <input type="range" id="base-height" min="0" max="50" step="1" value="10" oninput="updateSliderValue('base-height')">
                    </div>
                    <div class="slider-group">
                        <label>
                            Boundary Padding: <span class="slider-value" id="boundary-padding-value">100</span>m
                        </label>
                        <input type="range" id="boundary-padding" min="0" max="200" step="10" value="100" oninput="updateSliderValue('boundary-padding')">
                        <small style="color: #888; font-size: 11px;">Extra space around GPX track</small>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="include-base" checked>
                        <label for="include-base">Include Base (for 3D printing)</label>
                    </div>
                    <div style="margin: 10px 0;">
                        <label for="model-shape" style="display: block; margin-bottom: 5px; font-weight: 500;">Model Shape</label>
                        <select id="model-shape" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px;">
                            <option value="square">Square</option>
                            <option value="circle">Circle</option>
                            <option value="rectangle">Rectangle (Auto Aspect)</option>
                            <option value="hexagon">Hexagon</option>
                        </select>
                    </div>
                    <p style="margin: 10px 0 0; color: #555; font-size: 0.9em;">
                        Cesium buildings mode: buildings stream from Cesium tiles; final terrain uses high-detail DEM.
                    </p>
                </div>

                <!-- Generate -->
                <div class="section">
                    <h3>üöÄ Generate Model</h3>
                    <div class="checkbox-item" style="display:none;">
                        <input type="checkbox" id="fast-preview-mode" checked>
                        <label for="fast-preview-mode">Fast preview mode (omit buildings/railways)</label>
                    </div>
                    <button onclick="generateModel('preview')" class="success">Generate 3D Model</button>
                    <button onclick="generateModel('final')">Generate Final Quality</button>
                    <button onclick="export3MF()" class="secondary">Export to 3MF</button>
                </div>

                <!-- Object List -->
                <div class="section">
                    <h3>üéØ Objects</h3>
                    <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                        <button onclick="selectAllObjects()" style="flex: 1; font-size: 0.85em; padding: 6px;">Select All</button>
                        <button onclick="deselectAllObjects()" style="flex: 1; font-size: 0.85em; padding: 6px;">Deselect</button>
                        <button onclick="deleteSelectedObjects()" class="secondary" style="flex: 1; font-size: 0.85em; padding: 6px;">Delete Selected</button>
                    </div>
                    <div class="object-list" id="object-list">
                        <p style="color: #999; text-align: center;">No objects yet</p>
                    </div>
                    <p id="selection-count" style="font-size: 0.85em; color: #666; margin-top: 5px;"></p>
                </div>

                <!-- Labels -->
                <div class="section">
                    <h3>üè∑Ô∏è Add Label</h3>
                    <div class="label-input-group">
                        <input type="text" id="label-text" placeholder="Label text">
                        <button onclick="addLabel()">Add</button>
                    </div>
                </div>

            </div>

            <!-- 3D Viewer -->
            <div class="viewer-container">
                <div id="canvas-container"></div>
                <div id="status-message" class="status-floating"></div>
                <div id="selection-box" style="position: absolute; border: 2px dashed #ffff00; background: rgba(255, 255, 0, 0.1); pointer-events: none; display: none;"></div>
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Processing...</p>
                </div>
                <div id="render-debug" class="render-debug">Render diagnostics pending...</div>
                <div class="controls-overlay">
                    <h4>üéÆ Controls</h4>
                    <p><strong>Rotate:</strong> Left drag</p>
                    <p><strong>Pan:</strong> Right drag</p>
                    <p><strong>Zoom:</strong> Scroll</p>
                    <p><strong>Select:</strong> Shift+click</p>
                    <p><strong>Box select:</strong> Shift+drag</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Color Picker Modal -->
    <div id="color-picker-modal" class="color-picker-modal">
        <div class="color-picker-content">
            <h3>üé® Customize Building Color</h3>
            <p id="color-picker-building-name">Select a color for this building</p>

            <div class="color-input-group">
                <input type="color" id="building-color-picker" value="#aaaaaa">
                <input type="text" id="building-color-hex" value="#aaaaaa" placeholder="#RRGGBB" maxlength="7">
            </div>

            <div class="color-picker-actions">
                <button onclick="applyBuildingColor()" class="success">Apply</button>
                <button onclick="removeBuildingColor()" style="background: #e74c3c;">Remove Custom</button>
                <button onclick="closeColorPicker()" class="secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Global state
        let scene, camera, renderer, controls;
        let gpxData = null;
        let originalBounds = null;  // Store original GPX bounds before padding
        let elevationData = null;
        let osmFeatures = null;
        let currentMesh = null;
        let elevationFallbackReason = null;
        let selectedObjects = new Set();  // Multiple selection support
        let objectsList = [];
        let customBuildingColors = {};  // Store custom colors: { buildingId: hexColor }
        let currentColorPickerBuilding = null;  // Currently selected building for color picker

        // Selection in 3D view
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let isBoxSelecting = false;
        let boxSelectStart = { x: 0, y: 0 };
        let selectionBox = null;
        let statusHideTimer = null;
        let sceneOrigin = null;
        let lastRenderedMeshData = null;
        let terrainReferenceCenter = null;

        // Calculate padded bounds based on slider value
        function getPaddedBounds(bounds) {
            if (!bounds) return null;
            const paddingMeters = parseFloat(document.getElementById('boundary-padding').value) || 0;
            // Convert meters to degrees (approximate)
            // 1 degree latitude ‚âà 111,000 meters
            const avgLat = (bounds.north + bounds.south) / 2;
            const latPadding = paddingMeters / 111000;
            const lonPadding = paddingMeters / (111000 * Math.cos(avgLat * Math.PI / 180));

            return {
                north: bounds.north + latPadding,
                south: bounds.south - latPadding,
                east: bounds.east + lonPadding,
                west: bounds.west - lonPadding
            };
        }

        // Expand bounds to a square for circular model
        // The square must be large enough that an inscribed circle contains all original rectangular data
        function getSquareBoundsForCircle(bounds) {
            if (!bounds) return null;

            const avgLat = (bounds.north + bounds.south) / 2;
            const lonScale = Math.cos(avgLat * Math.PI / 180);

            // Convert bounds to approximate meters for calculation
            const latRangeMeters = (bounds.north - bounds.south) * 111000;
            const lonRangeMeters = (bounds.east - bounds.west) * 111000 * lonScale;

            // The circle that contains the entire rectangle has diameter = diagonal
            const diagonal = Math.sqrt(latRangeMeters * latRangeMeters + lonRangeMeters * lonRangeMeters);

            // We need a square with side = diagonal so the inscribed circle contains all data
            const squareSide = diagonal;

            // Calculate center of original bounds
            const centerLat = (bounds.north + bounds.south) / 2;
            const centerLon = (bounds.east + bounds.west) / 2;

            // Convert square side back to degrees
            const halfSideLat = (squareSide / 2) / 111000;
            const halfSideLon = (squareSide / 2) / (111000 * lonScale);

            return {
                north: centerLat + halfSideLat,
                south: centerLat - halfSideLat,
                east: centerLon + halfSideLon,
                west: centerLon - halfSideLon
            };
        }

        // Initialize Three.js scene
        function initScene() {
            const container = document.getElementById('canvas-container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 500, 2000);

            // Camera
            camera = new THREE.PerspectiveCamera(
                60,
                container.clientWidth / container.clientHeight,
                0.1,
                5000
            );
            camera.position.set(200, 200, 200);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(200, 500, 100);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Grid
            const gridHelper = new THREE.GridHelper(1000, 50, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Selection event handlers
            selectionBox = document.getElementById('selection-box');

            // Use pointerdown/move/up for better compatibility
            // Add to document to ensure we catch events even if OrbitControls intercepts
            document.addEventListener('pointerdown', onMouseDown, true);
            document.addEventListener('pointermove', onMouseMove, true);
            document.addEventListener('pointerup', onMouseUp, true);

            // Animation loop
            animate();
        }

        function onMouseDown(event) {
            // Check if shift key is pressed
            if (!event.shiftKey) return;

            // Check if click is on the canvas
            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            const isOnCanvas = event.clientX >= rect.left && event.clientX <= rect.right &&
                              event.clientY >= rect.top && event.clientY <= rect.bottom;

            if (!isOnCanvas) {
                return;
            }

            // Disable OrbitControls to prevent panning
            controls.enabled = false;

            // Stop event from reaching other handlers
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();

            boxSelectStart.x = event.clientX - rect.left;
            boxSelectStart.y = event.clientY - rect.top;
            isBoxSelecting = true;

            // Position selection box relative to viewer container
            const viewerRect = document.querySelector('.viewer-container').getBoundingClientRect();
            selectionBox.style.left = (event.clientX - viewerRect.left) + 'px';
            selectionBox.style.top = (event.clientY - viewerRect.top) + 'px';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';
        }

        function onMouseMove(event) {
            if (!isBoxSelecting) return;

            // Stop event from reaching OrbitControls during box selection
            event.preventDefault();
            event.stopPropagation();

            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            const viewerRect = document.querySelector('.viewer-container').getBoundingClientRect();

            const currentX = event.clientX - rect.left;
            const currentY = event.clientY - rect.top;

            // Calculate selection box dimensions relative to viewer container
            const startViewerX = boxSelectStart.x + (rect.left - viewerRect.left);
            const startViewerY = boxSelectStart.y + (rect.top - viewerRect.top);
            const currentViewerX = currentX + (rect.left - viewerRect.left);
            const currentViewerY = currentY + (rect.top - viewerRect.top);

            const left = Math.min(startViewerX, currentViewerX);
            const top = Math.min(startViewerY, currentViewerY);
            const width = Math.abs(currentViewerX - startViewerX);
            const height = Math.abs(currentViewerY - startViewerY);

            selectionBox.style.left = left + 'px';
            selectionBox.style.top = top + 'px';
            selectionBox.style.width = width + 'px';
            selectionBox.style.height = height + 'px';
        }

        function onMouseUp(event) {
            if (!isBoxSelecting) return;

            // Stop event from reaching OrbitControls
            event.preventDefault();
            event.stopPropagation();

            isBoxSelecting = false;
            selectionBox.style.display = 'none';

            // Re-enable OrbitControls
            controls.enabled = true;

            const canvas = renderer.domElement;
            const rect = canvas.getBoundingClientRect();
            const endX = event.clientX - rect.left;
            const endY = event.clientY - rect.top;

            // Calculate selection bounds (in canvas coordinates)
            const minX = Math.min(boxSelectStart.x, endX);
            const maxX = Math.max(boxSelectStart.x, endX);
            const minY = Math.min(boxSelectStart.y, endY);
            const maxY = Math.max(boxSelectStart.y, endY);

            const selectionWidth = maxX - minX;
            const selectionHeight = maxY - minY;

            // If it's a small drag (basically a click), do single object selection
            if (selectionWidth < 5 && selectionHeight < 5) {
                selectObjectAtPoint(boxSelectStart.x, boxSelectStart.y, rect);
            } else {
                // Box selection - find all objects within the box
                selectObjectsInBox(minX, minY, maxX, maxY, rect);
            }
        }

        function selectObjectAtPoint(x, y, rect) {
            // Convert to normalized device coordinates
            mouse.x = (x / rect.width) * 2 - 1;
            mouse.y = -(y / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Get all meshes from objectsList
            const meshes = objectsList.map(obj => obj.object).filter(obj => obj && obj.isMesh);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                // Find which object in objectsList was clicked
                const clickedMesh = intersects[0].object;
                const index = objectsList.findIndex(obj => obj.object === clickedMesh);
                if (index !== -1) {
                    selectObject(index);
                    showStatus(`Selected: ${objectsList[index].name}`, 'success');
                }
            }
        }

        function selectObjectsInBox(minX, minY, maxX, maxY, rect) {
            const selectedIndices = [];

            objectsList.forEach((obj, index) => {
                if (!obj.object || !obj.object.geometry) return;

                // Get the center of the object in screen space
                obj.object.geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                obj.object.geometry.boundingBox.getCenter(center);
                center.applyMatrix4(obj.object.matrixWorld);

                // Project to screen coordinates
                const screenPos = center.clone().project(camera);
                const screenX = (screenPos.x + 1) / 2 * rect.width;
                const screenY = (-screenPos.y + 1) / 2 * rect.height;

                // Check if center is within selection box
                if (screenX >= minX && screenX <= maxX && screenY >= minY && screenY <= maxY) {
                    // Check if object is in front of camera (not behind)
                    if (screenPos.z < 1) {
                        selectedIndices.push(index);
                    }
                }
            });

            // Select all objects in the box (add to selection, don't replace)
            selectedIndices.forEach(index => {
                if (!selectedObjects.has(index)) {
                    selectObject(index);
                }
            });

            if (selectedIndices.length > 0) {
                showStatus(`Selected ${selectedIndices.length} object(s)`, 'success');
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // File upload handler
        document.getElementById('gpx-file').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('file-name').textContent = file.name;

            const formData = new FormData();
            formData.append('file', file);

            try {
                showLoading(true);
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (result.success) {
                    gpxData = result.data;
                    // Store original bounds before padding
                    originalBounds = gpxData.bounds ? { ...gpxData.bounds } : null;
                    // Apply padding to bounds
                    if (gpxData.bounds) {
                        gpxData.bounds = getPaddedBounds(gpxData.bounds);
                    }
                    gpxData.needsRefetch = true;  // Flag to fetch data when generating
                    showStatus('GPX loaded! Adjust settings and click "Generate 3D Model".', 'success');
                } else {
                    showStatus('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error uploading file: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        });

        // Extract coordinates from Google Maps URL
        function extractCoordsFromGoogleMapsUrl(url) {
            // Try to extract coordinates from various Google Maps URL formats
            // Format 1: @-37.8470818,140.7846017 in the path
            // Format 2: !3d-37.8470861!4d140.7871766 in the data parameter (more precise)

            // Try the !3d...!4d format first (most precise)
            const dataMatch = url.match(/!3d(-?\d+\.?\d*)!4d(-?\d+\.?\d*)/);
            if (dataMatch) {
                return {
                    lat: parseFloat(dataMatch[1]),
                    lon: parseFloat(dataMatch[2])
                };
            }

            // Try the @lat,lng format
            const atMatch = url.match(/@(-?\d+\.?\d*),(-?\d+\.?\d*)/);
            if (atMatch) {
                return {
                    lat: parseFloat(atMatch[1]),
                    lon: parseFloat(atMatch[2])
                };
            }

            // Try query parameter format: q=lat,lng
            const qMatch = url.match(/[?&]q=(-?\d+\.?\d*),(-?\d+\.?\d*)/);
            if (qMatch) {
                return {
                    lat: parseFloat(qMatch[1]),
                    lon: parseFloat(qMatch[2])
                };
            }

            return null;
        }

        // Geocode address
        async function geocodeAddress() {
            const input = document.getElementById('address-input').value.trim();
            const btn = document.getElementById('geocode-btn');

            if (!input) {
                showStatus('Please enter an address or paste a Google Maps URL', 'error');
                return;
            }

            // Show loading state on button
            const originalText = btn.textContent;
            btn.textContent = 'Searching...';
            btn.disabled = true;

            // Check if input is a Google Maps URL
            if (input.includes('google.com/maps') || input.includes('goo.gl/maps')) {
                const coords = extractCoordsFromGoogleMapsUrl(input);
                if (coords) {
                    const lat = coords.lat;
                    const lon = coords.lon;

                    // Always include address in originalBounds so padding slider works correctly
                    if (originalBounds) {
                        // Check if too far from GPX area
                        const maxExpansion = 0.1;  // ~11km
                        const latDiff = Math.min(Math.abs(lat - originalBounds.south), Math.abs(lat - originalBounds.north));
                        const lonDiff = Math.min(Math.abs(lon - originalBounds.west), Math.abs(lon - originalBounds.east));
                        const isOutside = lat < originalBounds.south || lat > originalBounds.north ||
                                         lon < originalBounds.west || lon > originalBounds.east;

                        if (isOutside && (latDiff > maxExpansion || lonDiff > maxExpansion)) {
                            showStatus(`Location is too far from GPX area (${(Math.max(latDiff, lonDiff) * 111).toFixed(1)}km away). Max expansion is ~11km.`, 'error');
                            btn.textContent = originalText;
                            btn.disabled = false;
                            return;
                        }

                        // Always expand originalBounds to include the address location
                        const margin = 0.001;
                        originalBounds = {
                            north: Math.max(originalBounds.north, lat + margin),
                            south: Math.min(originalBounds.south, lat - margin),
                            east: Math.max(originalBounds.east, lon + margin),
                            west: Math.min(originalBounds.west, lon - margin)
                        };

                        // Apply padding to the expanded bounds
                        gpxData.bounds = getPaddedBounds(originalBounds);
                        gpxData.needsRefetch = true;
                    }

                    // Store location and create marker immediately
                    geocodedLocation = { lat, lon };
                    createMarker(lat, lon);

                    // Enable the "show only address building" checkbox
                    document.getElementById('show-only-address-building').disabled = false;
                    document.getElementById('address-status').textContent = `Coordinates from Google Maps: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;

                    showStatus(`Found coordinates from Google Maps URL!`, 'success');

                    btn.textContent = originalText;
                    btn.disabled = false;
                    return;
                } else {
                    showStatus('Could not extract coordinates from Google Maps URL', 'error');
                    btn.textContent = originalText;
                    btn.disabled = false;
                    return;
                }
            }

            // Otherwise, use the geocoding API
            try {
                const response = await fetch('/api/geocode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: input })
                });

                const result = await response.json();

                if (result.success) {
                    const lat = result.location.lat;
                    const lon = result.location.lon;

                    // Always include address in originalBounds so padding slider works correctly
                    if (originalBounds) {
                        // Check if too far from GPX area
                        const maxExpansion = 0.1;  // ~11km
                        const latDiff = Math.min(Math.abs(lat - originalBounds.south), Math.abs(lat - originalBounds.north));
                        const lonDiff = Math.min(Math.abs(lon - originalBounds.west), Math.abs(lon - originalBounds.east));
                        const isOutside = lat < originalBounds.south || lat > originalBounds.north ||
                                         lon < originalBounds.west || lon > originalBounds.east;

                        if (isOutside && (latDiff > maxExpansion || lonDiff > maxExpansion)) {
                            showStatus(`Address is too far from GPX area (${(Math.max(latDiff, lonDiff) * 111).toFixed(1)}km away). Max expansion is ~11km.`, 'error');
                            btn.textContent = originalText;
                            btn.disabled = false;
                            return;
                        }

                        // Always expand originalBounds to include the address location
                        const margin = 0.001;
                        originalBounds = {
                            north: Math.max(originalBounds.north, lat + margin),
                            south: Math.min(originalBounds.south, lat - margin),
                            east: Math.max(originalBounds.east, lon + margin),
                            west: Math.min(originalBounds.west, lon - margin)
                        };

                        // Apply padding to the expanded bounds
                        gpxData.bounds = getPaddedBounds(originalBounds);
                        gpxData.needsRefetch = true;
                    }

                    // Store location and create marker
                    geocodedLocation = { lat, lon };
                    createMarker(lat, lon);

                    // Enable the "show only address building" checkbox
                    document.getElementById('show-only-address-building').disabled = false;
                    document.getElementById('address-status').textContent = `Address: ${result.location.address}`;
                    showStatus(`Address found: ${result.location.address}`, 'success');
                } else {
                    showStatus('Error: ' + result.error, 'error');
                    document.getElementById('show-only-address-building').disabled = true;
                    document.getElementById('address-status').textContent = '';
                }
            } catch (error) {
                showStatus('Error geocoding address: ' + error.message, 'error');
            } finally {
                // Restore button state
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        // Fetch elevation data
        async function fetchElevationData(bounds, previewMode) {
            try {
                showStatus('Fetching elevation data...', 'info');
                const resolution = previewMode ? 220 : 500;
                const response = await fetch('/api/elevation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        bounds,
                        resolution,
                        source_mode: 'cesium',
                        preview_mode: previewMode
                    })
                });

                const result = await response.json();

                if (result.success) {
                    elevationData = result.elevation;
                    elevationFallbackReason = result.fallback_reason || null;
                    showStatus('Elevation data loaded!', 'success');
                } else {
                    showStatus('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error fetching elevation: ' + error.message, 'error');
            }
        }

        // Fetch OSM features
        async function fetchOSMFeatures(bounds, previewMode) {
            try {
                showStatus('Fetching map features...', 'info');
                const response = await fetch('/api/osm-features', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        bounds,
                        features: ['roads', 'water', 'buildings', 'railways', 'landuse']
                    })
                });

                const result = await response.json();
                if (result.success) {
                    osmFeatures = result.features || {};
                    if (previewMode) {
                        // Keep preview responsive while preserving final-quality detail path.
                        osmFeatures = {
                            roads: (osmFeatures.roads || []).slice(0, 120),
                            water: (osmFeatures.water || []).slice(0, 30),
                            buildings: (osmFeatures.buildings || []).slice(0, 120),
                            railways: (osmFeatures.railways || []).slice(0, 60),
                            landuse: (osmFeatures.landuse || []).slice(0, 30)
                        };
                    }
                    showStatus('Map features loaded!', 'success');
                } else {
                    throw new Error(result.error || 'Failed to fetch OSM features');
                }
            } catch (error) {
                showStatus('Error fetching OSM features: ' + error.message, 'error');
            }
        }

        // Track whether last fetch was for circular model (to detect changes)
        let lastFetchShape = 'square';
        let lastFetchMode = 'preview';

        // Generate 3D model
        async function generateModel(mode = 'preview') {
            if (!elevationData && !gpxData?.bounds) {
                showStatus('Please upload a GPX file first', 'error');
                return;
            }

            let previewMode;
            if (mode === 'final') {
                previewMode = false;
            } else if (mode === 'preview') {
                previewMode = true;
            } else {
                previewMode = document.getElementById('fast-preview-mode').checked;
            }
            const modelShape = document.getElementById('model-shape').value;

            // Need refetch if shape changed since last fetch
            const shapeChanged = modelShape !== lastFetchShape;
            const modeChanged = (previewMode ? 'preview' : 'final') !== lastFetchMode;

            // Fetch data if needed (first time, bounds changed, or shape changed)
            if (gpxData && (gpxData.needsRefetch || !elevationData || shapeChanged || modeChanged)) {
                showStatus('Fetching elevation and map data...', 'info');
                showLoading(true);
                try {
                    // Use square bounds for square/circle/hexagon, regular bounds for rectangle
                    let fetchBounds = gpxData.bounds;
                    if (modelShape === 'square' || modelShape === 'circle' || modelShape === 'hexagon') {
                        fetchBounds = getSquareBoundsForCircle(gpxData.bounds);
                        console.log(`${modelShape} shape: expanding to square bounds`, fetchBounds);
                    }

                    await Promise.all([
                        fetchElevationData(fetchBounds, previewMode),
                        fetchOSMFeatures(fetchBounds, previewMode)
                    ]);
                    gpxData.needsRefetch = false;
                    lastFetchShape = modelShape;
                    lastFetchMode = previewMode ? 'preview' : 'final';
                } catch (error) {
                    showStatus('Error fetching data: ' + error.message, 'error');
                    showLoading(false);
                    return;
                }
            }

            if (!elevationData) {
                showStatus('Failed to fetch elevation data', 'error');
                showLoading(false);
                return;
            }

            console.log('[DEBUG] Elevation data check passed');
            const showOnlyAddressBuilding = document.getElementById('show-only-address-building').checked;
            console.log('[DEBUG] Got showOnlyAddressBuilding:', showOnlyAddressBuilding);

            const options = {
                vertical_scale: parseFloat(document.getElementById('vertical-scale').value),
                model_width: parseFloat(document.getElementById('model-width').value),
                base_height: parseFloat(document.getElementById('base-height').value),
                include_base: document.getElementById('include-base').checked,
                model_shape: document.getElementById('model-shape').value,
                building_mode: 'hybrid',
                terrain_source_mode: 'cesium',
                building_mesh_simplify: true,
                building_mesh_target_ratio_preview: 0.2,
                building_mesh_target_ratio_final: 0.4,
                gpx_tracks: gpxData ? gpxData.tracks : [],  // Include GPX tracks for rendering
                address_location: geocodedLocation,  // Pass the geocoded address location
                show_only_address_building: showOnlyAddressBuilding,  // Whether to show only the address building
                custom_building_colors: customBuildingColors,  // Pass custom building colors
                preview_mode: previewMode,
                generation_mode: previewMode ? 'preview' : 'final',
                _terrain_fallback_reason: elevationFallbackReason
            };

            console.log('[DEBUG] Options object built:', options);

            try {
                showLoading(true);
                showStatus('Generating 3D model...', 'info');

                console.log('[DEBUG] About to stringify payload...');
                const payload = {
                    elevation: elevationData,
                    features: osmFeatures || {},
                    options
                };
                console.log('[DEBUG] Payload object created, stringifying...');
                const payloadStr = JSON.stringify(payload);
                console.log('[DEBUG] Stringify complete, payload size:', payloadStr.length, 'characters');

                console.log('[DEBUG] Making fetch call to /api/generate');
                let response;
                try {
                    response = await fetch('/api/generate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: payloadStr
                    });
                    console.log('[DEBUG] Fetch returned, status:', response.status);
                } catch (fetchError) {
                    console.error('[DEBUG] Fetch failed with error:', fetchError);
                    throw fetchError;
                }

                console.log('[DEBUG] About to parse JSON response');
                const result = await response.json();
                console.log('[DEBUG] JSON parsed successfully');

                if (result.success) {
                    currentMesh = result.mesh;
                    renderMesh(currentMesh);
                    updateObjectList(currentMesh);
                    updateRenderDiagnostics(currentMesh);

                    // Display validation results
                    if (result.validation) {
                        displayValidationResults(
                            result.validation,
                            result.timings,
                            result.mode,
                            result.metadata || result.mesh?.metadata || {}
                        );
                    } else {
                        showStatus('Model generated successfully!', 'success');
                    }
                } else {
                    showStatus('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error generating model: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Display mesh validation results
        function displayValidationResults(validation, timings, mode, metadata = {}) {
            let message = 'Model generated successfully!';
            let messageType = 'success';
            if (mode) {
                message += `\nMode: ${mode}`;
            }
            if (metadata.terrain_source_used || metadata.building_source_used) {
                message += `\n\nSources: terrain=${metadata.terrain_source_used || 'default'}, buildings=${metadata.building_source_used || 'none'}`;
            }
            if (metadata.vertices_count || metadata.faces_count || metadata.features_count) {
                const terrainVertices = metadata.vertices_count ?? 0;
                const terrainFaces = metadata.faces_count ?? 0;
                const featuresCount = metadata.features_count ?? 0;
                message += `\nCounts: terrain_vertices=${terrainVertices}, terrain_faces=${terrainFaces}, features=${featuresCount}`;
            }
            if (metadata.feature_type_counts) {
                const parts = [];
                Object.entries(metadata.feature_type_counts).forEach(([key, value]) => {
                    parts.push(`${key}=${value}`);
                });
                if (parts.length > 0) {
                    message += `\nFeature types: ${parts.join(', ')}`;
                }
            }
            if (metadata.fallback_reasons) {
                if (metadata.fallback_reasons.terrain) {
                    message += `\nTerrain fallback: ${metadata.fallback_reasons.terrain}`;
                }
                if (metadata.fallback_reasons.building) {
                    message += `\nBuilding fallback: ${metadata.fallback_reasons.building}`;
                }
            }

            // Show fixes that were applied
            if (validation.fixes_applied && validation.fixes_applied.length > 0) {
                message += '\n\nAuto-fixes applied:';
                validation.fixes_applied.forEach(fix => {
                    message += `\n- ${fix}`;
                });
                messageType = 'info';
            }

            // Show warnings
            if (validation.warnings && validation.warnings.length > 0) {
                message += '\n\nWarnings:';
                validation.warnings.forEach(warning => {
                    message += `\n- ${warning}`;
                });

                if (!validation.is_printable) {
                    message += '\n\nModel may have printability issues!';
                    messageType = 'error';
                }
            }

            if (timings) {
                message += `\n\nTiming: parse=${timings.parse_seconds}s, mesh=${timings.mesh_seconds}s, validation=${timings.validation_seconds}s, total=${timings.total_seconds}s`;
            }

            showStatus(message, messageType);
        }

        // Generate descriptive display name for a feature
        function generateDisplayName(feature, isAddressBuilding) {
            if (isAddressBuilding) {
                return 'Address Building';
            }

            const name = feature.name;
            const type = feature.type;

            // Format type nicely
            const typeLabels = {
                'water': 'Water',
                'road': 'Road',
                'building': 'Building',
                'railway': 'Railway'
            };
            const typeLabel = typeLabels[type] || type;

            // Road type formatting
            const roadTypeLabels = {
                'motorway': 'Motorway',
                'trunk': 'Trunk Road',
                'primary': 'Primary Road',
                'secondary': 'Secondary Road',
                'tertiary': 'Tertiary Road',
                'residential': 'Street',
                'service': 'Service Road',
                'track': 'Track',
                'path': 'Path',
                'footway': 'Footway',
                'cycleway': 'Cycleway',
                'unclassified': 'Road'
            };

            if (type === 'road') {
                const roadType = feature.road_type || 'road';
                const roadLabel = roadTypeLabels[roadType] || 'Road';
                if (name) {
                    return `${name}`;  // e.g., "Main Street"
                } else {
                    return roadLabel;  // e.g., "Residential Street"
                }
            }

            if (type === 'water') {
                if (name) {
                    return `${name}`;  // e.g., "Blue Lake"
                } else {
                    return 'Water Body';
                }
            }

            if (type === 'building') {
                const buildingType = feature.building_type || 'building';
                const buildingLabels = {
                    'yes': 'Building',
                    'house': 'House',
                    'residential': 'Residence',
                    'commercial': 'Commercial',
                    'industrial': 'Industrial',
                    'retail': 'Retail',
                    'church': 'Church',
                    'school': 'School',
                    'hospital': 'Hospital',
                    'hotel': 'Hotel',
                    'garage': 'Garage',
                    'shed': 'Shed'
                };
                const buildingLabel = buildingLabels[buildingType] || 'Building';
                if (name) {
                    return `${name}`;  // e.g., "Town Hall"
                } else {
                    return buildingLabel;  // e.g., "House"
                }
            }

            // Default: use name or type
            return name || typeLabel;
        }

        // Render mesh in Three.js
        function renderMesh(meshData) {
            // Clear existing objects (except lights and grid)
            while(scene.children.length > 3) {
                scene.remove(scene.children[3]);
            }
            objectsList = [];
            selectedObjects.clear();
            terrainReferenceCenter = computeTerrainCenter(meshData);
            sceneOrigin = terrainReferenceCenter || { x: 0, y: 0, z: 0 };
            lastRenderedMeshData = meshData;

            if (!meshData || !meshData.terrain || !meshData.terrain.vertices || meshData.terrain.vertices.length === 0) {
                console.warn('No terrain to render', meshData);
                showStatus('No terrain received from server', 'error');
                return;
            }

            // Render terrain
            if (meshData.terrain) {
                if (!meshData.terrain.vertices || meshData.terrain.vertices.length === 0) {
                    console.warn('Terrain has no vertices');
                }
                const terrainObj = createMeshFromData(meshData.terrain, 0x8B7355, 'terrain');
                terrainObj.userData = { type: 'terrain', id: 'terrain', originalColor: 0x8B7355 };
                scene.add(terrainObj);
                objectsList.push({ type: 'Terrain', id: 'terrain', name: 'Terrain', object: terrainObj });
            }

            // Render features
            if (meshData.features) {
                console.log('Features count:', meshData.features.length);
                meshData.features.forEach((feature, index) => {
                    console.log(`Feature ${index}: type=${feature.type}, vertices=${feature.vertices?.length}, faces=${feature.faces?.length}`);

                    // Skip features with no geometry
                    if (!feature.vertices || !feature.faces || feature.vertices.length === 0 || feature.faces.length === 0) {
                        console.warn(`Skipping feature ${feature.type} - no geometry`);
                        return;
                    }

                    let color;
                    let isAddressBuilding = feature.is_address_building === true;

                    switch(feature.type) {
                        case 'building':
                            color = isAddressBuilding ? 0xffcc00 : 0xaaaaaa;  // Yellow for address building
                            break;
                        case 'road': color = 0x444444; break;
                        case 'water': color = 0x4a90e2; break;
                        default: color = 0x888888;
                    }

                    const featureObj = createMeshFromData(feature, color, feature.type || 'feature');
                    featureObj.userData = { type: feature.type, id: feature.id, isAddressBuilding: isAddressBuilding, originalColor: color };

                    // Add emissive for address building to make it stand out
                    if (isAddressBuilding) {
                        featureObj.material.emissive = new THREE.Color(0x775500);
                        featureObj.material.polygonOffset = true;
                        featureObj.material.polygonOffsetFactor = -2;
                        featureObj.material.polygonOffsetUnits = -2;
                        const edges = new THREE.EdgesGeometry(featureObj.geometry);
                        const edgeLines = new THREE.LineSegments(
                            edges,
                            new THREE.LineBasicMaterial({ color: 0x111111, linewidth: 2 })
                        );
                        edgeLines.position.copy(featureObj.position);
                        edgeLines.rotation.copy(featureObj.rotation);
                        edgeLines.scale.copy(featureObj.scale);
                        scene.add(edgeLines);
                        addAddressBeacon(featureObj);
                    }

                    // Generate descriptive display name
                    let displayName = generateDisplayName(feature, isAddressBuilding);

                    scene.add(featureObj);
                    objectsList.push({
                        type: feature.type,
                        id: feature.id,
                        name: displayName,
                        object: featureObj
                    });
                });
            }

            // Render GPX track (red)
            if (meshData.gpx_track && meshData.gpx_track.vertices && meshData.gpx_track.vertices.length > 0) {
                const trackColor = 0xff0000;  // Bright red
                const trackObj = createMeshFromData(meshData.gpx_track, trackColor, 'gpx_track');
                // Make it emissive so it stands out
                trackObj.material.emissive = new THREE.Color(0x660000);
                trackObj.userData = { type: 'gpx_track', id: 'gpx_track', originalColor: trackColor };
                scene.add(trackObj);
                objectsList.push({
                    type: 'GPX',
                    id: 'gpx_track',
                    name: 'GPX Track',
                    object: trackObj
                });
            }

            // Center camera on model
            centerCamera();
            const showOnlyAddressBuilding = document.getElementById('show-only-address-building')?.checked;
            if (showOnlyAddressBuilding) {
                focusAddressBuilding();
            }
            forceRenderRefresh('renderMesh');
        }

        function computeSceneOrigin(meshData) {
            const vertices = meshData?.terrain?.vertices;
            if (!vertices || vertices.length === 0) {
                return { x: 0, y: 0, z: 0 };
            }

            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            vertices.forEach((vertex) => {
                if (!vertex || vertex.length < 3) return;
                const [x, y, z] = vertex;
                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) return;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                minZ = Math.min(minZ, z);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
                maxZ = Math.max(maxZ, z);
            });

            if (![minX, minY, minZ, maxX, maxY, maxZ].every(Number.isFinite)) {
                return { x: 0, y: 0, z: 0 };
            }

            return {
                x: (minX + maxX) / 2,
                y: (minY + maxY) / 2,
                z: (minZ + maxZ) / 2
            };
        }

        function computeTerrainCenter(meshData) {
            const vertices = meshData?.terrain?.vertices;
            if (!vertices || vertices.length === 0) {
                return { x: 0, y: 0, z: 0 };
            }

            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            vertices.forEach((vertex) => {
                if (!vertex || vertex.length < 3) return;
                const [x, y, z] = vertex;
                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) return;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                minZ = Math.min(minZ, z);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
                maxZ = Math.max(maxZ, z);
            });

            if (![minX, minY, minZ, maxX, maxY, maxZ].every(Number.isFinite)) {
                return { x: 0, y: 0, z: 0 };
            }

            return {
                x: (minX + maxX) / 2,
                y: (minY + maxY) / 2,
                z: (minZ + maxZ) / 2
            };
        }

        function computeBounds(vertices) {
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            vertices.forEach((vertex) => {
                if (!vertex || vertex.length < 3) return;
                const [x, y, z] = vertex;
                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) return;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                minZ = Math.min(minZ, z);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
                maxZ = Math.max(maxZ, z);
            });

            if (![minX, minY, minZ, maxX, maxY, maxZ].every(Number.isFinite)) {
                return null;
            }
            return { minX, minY, minZ, maxX, maxY, maxZ };
        }

        function computeVertexCenter(vertices) {
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            vertices.forEach((vertex) => {
                if (!vertex || vertex.length < 3) return;
                const [x, y, z] = vertex;
                if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) return;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                minZ = Math.min(minZ, z);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
                maxZ = Math.max(maxZ, z);
            });

            if (![minX, minY, minZ, maxX, maxY, maxZ].every(Number.isFinite)) {
                return { x: 0, y: 0, z: 0 };
            }

            return {
                x: (minX + maxX) / 2,
                y: (minY + maxY) / 2,
                z: (minZ + maxZ) / 2
            };
        }

        // Create Three.js mesh from vertex/face data
        function createMeshFromData(meshData, color, meshType = 'feature') {
            const geometry = new THREE.BufferGeometry();

            const origin = sceneOrigin || { x: 0, y: 0, z: 0 };
            const vertices = [];
            meshData.vertices.forEach((vertex) => {
                vertices.push(
                    vertex[0] - origin.x,
                    vertex[1] - origin.y,
                    vertex[2] - origin.z
                );
            });
            const indices = meshData.faces.flat();

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({
                color: color,
                flatShading: false,
                side: THREE.DoubleSide
            });

            return new THREE.Mesh(geometry, material);
        }

        function addAddressBeacon(buildingObj) {
            if (!buildingObj || !buildingObj.geometry) return;
            buildingObj.geometry.computeBoundingBox();
            const bb = buildingObj.geometry.boundingBox.clone().applyMatrix4(buildingObj.matrixWorld);
            const center = bb.getCenter(new THREE.Vector3());
            const size = bb.getSize(new THREE.Vector3());
            const beaconHeight = Math.max(14, size.y * 2.0);
            const beaconRadius = Math.max(0.8, Math.min(size.x, size.z) * 0.15);

            const shaft = new THREE.Mesh(
                new THREE.CylinderGeometry(beaconRadius, beaconRadius, beaconHeight, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ffd0, depthTest: false, transparent: true, opacity: 0.9 })
            );
            shaft.position.set(center.x, bb.max.y + (beaconHeight * 0.5) + 0.5, center.z);
            shaft.renderOrder = 10;
            shaft.userData = { type: 'address_beacon' };
            scene.add(shaft);

            const tip = new THREE.Mesh(
                new THREE.SphereGeometry(beaconRadius * 1.6, 20, 20),
                new THREE.MeshBasicMaterial({ color: 0x00ffd0, depthTest: false })
            );
            tip.position.set(center.x, shaft.position.y + (beaconHeight * 0.5), center.z);
            tip.renderOrder = 11;
            tip.userData = { type: 'address_beacon' };
            scene.add(tip);
        }

        function focusAddressBuilding() {
            const addr = objectsList.find((entry) => entry.object?.userData?.isAddressBuilding);
            if (!addr || !addr.object || !camera) return;
            const obj = addr.object;
            obj.geometry.computeBoundingBox();
            const bb = obj.geometry.boundingBox.clone().applyMatrix4(obj.matrixWorld);
            const center = bb.getCenter(new THREE.Vector3());
            const size = bb.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z, 8);
            const distance = Math.max(26, maxDim * 3.2);

            camera.position.set(center.x + distance, center.y + (distance * 0.7), center.z + distance);
            controls.target.copy(center);
            controls.update();
            forceRenderRefresh('focusAddressBuilding');
        }

        // Center camera on model
        function centerCamera() {
            // Only compute bounding box from model objects, not helpers/lights
            const box = new THREE.Box3();
            let hasObjects = false;
            const showOnlyAddressBuilding = document.getElementById('show-only-address-building')?.checked;
            const frameTypes = showOnlyAddressBuilding
                ? new Set(['terrain', 'road', 'water', 'building'])
                : new Set(['terrain', 'road', 'water']);

            scene.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const childType = child.userData?.type;
                    if (childType && !frameTypes.has(childType)) {
                        return;
                    }
                    child.geometry.computeBoundingBox();
                    const childBox = child.geometry.boundingBox.clone();
                    childBox.applyMatrix4(child.matrixWorld);
                    const min = childBox.min;
                    const max = childBox.max;
                    if (![min.x, min.y, min.z, max.x, max.y, max.z].every(Number.isFinite)) {
                        console.warn('Skipping mesh with invalid bounds', child);
                        return;
                    }
                    box.union(childBox);
                    hasObjects = true;
                }
            });

            if (!hasObjects) {
                updateRenderDiagnostics(null, 'centerCamera: no mesh objects found');
                return;
            }

            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());

            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));

            cameraZ = Math.max(cameraZ * 1.5, 30);

            // Update camera far plane to see large models
            camera.far = Math.max(maxDim * 12, 2000);
            camera.updateProjectionMatrix();

            camera.position.set(center.x + cameraZ, center.y + cameraZ * 0.5, center.z + cameraZ);
            camera.lookAt(center);
            controls.target.copy(center);
            controls.update();
            updateRenderDiagnostics(
                null,
                `center=(${center.x.toFixed(1)}, ${center.y.toFixed(1)}, ${center.z.toFixed(1)}) size=(${size.x.toFixed(1)}, ${size.y.toFixed(1)}, ${size.z.toFixed(1)}) cam=(${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`
            );
        }

        function forceRenderRefresh(source = 'manual') {
            if (!renderer || !scene || !camera) return;

            scene.updateMatrixWorld(true);
            controls.update();
            renderer.render(scene, camera);

            requestAnimationFrame(() => {
                controls.update();
                renderer.render(scene, camera);
                updateRenderDiagnostics(null, `forceRefresh=${source}`);
            });
        }

        function countRenderableMeshes() {
            return scene.children.filter((child) => child.isMesh).length;
        }

        function updateRenderDiagnostics(meshData, note = '') {
            const debugEl = document.getElementById('render-debug');
            if (!debugEl || !camera || !scene) return;
            const diagnosticMeshData = meshData || lastRenderedMeshData || null;

            const terrainVerts = diagnosticMeshData?.terrain?.vertices?.length || 0;
            const terrainFaces = diagnosticMeshData?.terrain?.faces?.length || 0;
            const features = diagnosticMeshData?.features?.length || 0;
            const gpxVerts = diagnosticMeshData?.gpx_track?.vertices?.length || 0;
            const origin = sceneOrigin || { x: 0, y: 0, z: 0 };

            const lines = [
                `meshes=${countRenderableMeshes()} objects=${objectsList.length}`,
                `terrain(v/f)=${terrainVerts}/${terrainFaces} features=${features} gpxVerts=${gpxVerts}`,
                `cam=(${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)}) target=(${controls.target.x.toFixed(1)}, ${controls.target.y.toFixed(1)}, ${controls.target.z.toFixed(1)})`,
                `origin=(${origin.x.toFixed(1)}, ${origin.y.toFixed(1)}, ${origin.z.toFixed(1)})`,
                note ? `note=${note}` : ''
            ].filter(Boolean);

            debugEl.textContent = lines.join('\n');
        }

        // Update object list
        function updateObjectList(meshData) {
            const list = document.getElementById('object-list');
            list.innerHTML = '';

            // Group features by type for counting
            const typeCounts = {};
            objectsList.forEach(obj => {
                const t = obj.type;
                typeCounts[t] = (typeCounts[t] || 0) + 1;
            });

            objectsList.forEach((obj, index) => {
                const item = document.createElement('div');
                item.className = 'object-item';

                // Type badge colors
                const badgeColors = {
                    'Terrain': '#8B7355',
                    'water': '#4a90e2',
                    'road': '#444444',
                    'building': '#aaaaaa',
                    'GPX': '#ff0000',
                    'marker': '#ff0000',
                    'label': '#667eea'
                };
                const badgeColor = badgeColors[obj.type] || '#888888';

                // Format type label
                const typeLabels = {
                    'water': 'Water',
                    'road': 'Road',
                    'building': 'Bldg',
                    'Terrain': 'Terrain',
                    'GPX': 'GPX',
                    'marker': 'Marker',
                    'label': 'Label'
                };
                const typeLabel = typeLabels[obj.type] || obj.type;

                // Add color picker button for buildings
                let colorPickerButton = '';
                if (obj.type === 'building' && obj.id) {
                    const customColor = customBuildingColors[obj.id] || badgeColor;
                    colorPickerButton = `
                        <div class="building-color-indicator"
                             style="background: ${customColor};"
                             onclick="event.stopPropagation(); openColorPicker(${index}, '${obj.id}', '${obj.name.replace(/'/g, "\\'")}')">
                        </div>
                    `;
                }

                item.innerHTML = `
                    <span class="object-info">
                        <span class="type-badge" style="background: ${badgeColor}; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.75em; margin-right: 6px;">${typeLabel}</span>
                        <span class="object-name">${obj.name}</span>
                        ${colorPickerButton}
                    </span>
                    <button onclick="event.stopPropagation(); deleteObject(${index})">X</button>
                `;
                // Mark as selected if in selectedObjects
                if (selectedObjects.has(index)) {
                    item.classList.add('selected');
                }

                item.onclick = (e) => {
                    if (e.target.tagName !== 'BUTTON') {
                        selectObject(index);
                    }
                };
                list.appendChild(item);
            });

            updateSelectionCount();
        }

        // Color Picker Functions
        function openColorPicker(buildingIndex, buildingId, buildingName) {
            currentColorPickerBuilding = { index: buildingIndex, id: buildingId, name: buildingName };

            // Set current color or default
            const currentColor = customBuildingColors[buildingId] || '#aaaaaa';

            document.getElementById('building-color-picker').value = currentColor;
            document.getElementById('building-color-hex').value = currentColor;
            document.getElementById('color-picker-building-name').textContent = `Customize color for: ${buildingName}`;

            // Show modal
            document.getElementById('color-picker-modal').classList.add('active');

            // Sync color picker and hex input
            const colorPicker = document.getElementById('building-color-picker');
            const hexInput = document.getElementById('building-color-hex');

            colorPicker.oninput = () => {
                hexInput.value = colorPicker.value;
            };

            hexInput.oninput = () => {
                if (/^#[0-9A-F]{6}$/i.test(hexInput.value)) {
                    colorPicker.value = hexInput.value;
                }
            };
        }

        function closeColorPicker() {
            document.getElementById('color-picker-modal').classList.remove('active');
            currentColorPickerBuilding = null;
        }

        function applyBuildingColor() {
            if (!currentColorPickerBuilding) return;

            const color = document.getElementById('building-color-picker').value;
            const buildingId = currentColorPickerBuilding.id;

            // Store custom color
            customBuildingColors[buildingId] = color;

            // Update the building color in 3D view
            const buildingObj = objectsList[currentColorPickerBuilding.index];
            if (buildingObj && buildingObj.object) {
                buildingObj.object.material.color.setStyle(color);
            }

            // Close modal and refresh object list
            closeColorPicker();
            updateObjectList(currentMesh);

            showStatus('Building color updated! Regenerate model to apply in export.', 'success');
        }

        function removeBuildingColor() {
            if (!currentColorPickerBuilding) return;

            const buildingId = currentColorPickerBuilding.id;

            // Remove custom color
            delete customBuildingColors[buildingId];

            // Reset to default color
            const buildingObj = objectsList[currentColorPickerBuilding.index];
            if (buildingObj && buildingObj.object) {
                buildingObj.object.material.color.setHex(0xaaaaaa);
            }

            // Close modal and refresh object list
            closeColorPicker();
            updateObjectList(currentMesh);

            showStatus('Building color reset to default.', 'info');
        }

        // Toggle object selection (multi-select)
        function selectObject(index, addToSelection = true) {
            const obj = objectsList[index]?.object;
            if (!obj) return;

            if (selectedObjects.has(index)) {
                // Deselect this object
                selectedObjects.delete(index);
                document.querySelectorAll('.object-item')[index]?.classList.remove('selected');

                // Restore original color
                const originalColor = obj.userData.originalColor;
                if (originalColor !== undefined) {
                    obj.material.color.setHex(originalColor);
                }
                // Reset emissive (unless it's address building or GPX track)
                if (!obj.userData.isAddressBuilding && obj.userData.type !== 'gpx_track') {
                    obj.material.emissive.setHex(0x000000);
                } else {
                    obj.material.emissive.setHex(0x660000);
                }
            } else {
                // Select this object
                selectedObjects.add(index);
                document.querySelectorAll('.object-item')[index]?.classList.add('selected');

                // Highlight with bright yellow color and strong emissive
                obj.material.color.setHex(0xffff00);
                obj.material.emissive.setHex(0x888800);
            }

            updateSelectionCount();
        }

        // Select all objects
        function selectAllObjects() {
            objectsList.forEach((obj, index) => {
                if (!selectedObjects.has(index)) {
                    selectedObjects.add(index);
                    document.querySelectorAll('.object-item')[index]?.classList.add('selected');
                    if (obj.object) {
                        obj.object.material.color.setHex(0xffff00);
                        obj.object.material.emissive.setHex(0x888800);
                    }
                }
            });
            updateSelectionCount();
        }

        // Deselect all objects
        function deselectAllObjects() {
            selectedObjects.forEach(index => {
                const obj = objectsList[index]?.object;
                if (obj) {
                    document.querySelectorAll('.object-item')[index]?.classList.remove('selected');
                    const originalColor = obj.userData.originalColor;
                    if (originalColor !== undefined) {
                        obj.material.color.setHex(originalColor);
                    }
                    if (!obj.userData.isAddressBuilding && obj.userData.type !== 'gpx_track') {
                        obj.material.emissive.setHex(0x000000);
                    } else {
                        obj.material.emissive.setHex(0x660000);
                    }
                }
            });
            selectedObjects.clear();
            updateSelectionCount();
        }

        // Delete all selected objects
        function deleteSelectedObjects() {
            if (selectedObjects.size === 0) {
                showStatus('No objects selected', 'error');
                return;
            }

            if (!confirm(`Delete ${selectedObjects.size} selected object(s)?`)) {
                return;
            }

            // Sort indices in descending order to delete from end first (preserves indices)
            const indicesToDelete = Array.from(selectedObjects).sort((a, b) => b - a);

            indicesToDelete.forEach(index => {
                scene.remove(objectsList[index].object);
                objectsList.splice(index, 1);
            });

            selectedObjects.clear();
            updateObjectList(currentMesh);
            updateSelectionCount();
            showStatus(`Deleted ${indicesToDelete.length} object(s)`, 'success');
        }

        // Update selection count display
        function updateSelectionCount() {
            const countEl = document.getElementById('selection-count');
            if (selectedObjects.size > 0) {
                countEl.textContent = `${selectedObjects.size} object(s) selected`;
            } else {
                countEl.textContent = '';
            }
        }

        // Delete single object
        function deleteObject(index) {
            if (confirm('Delete this object?')) {
                scene.remove(objectsList[index].object);
                objectsList.splice(index, 1);
                // Update selectedObjects indices (remove deleted, shift higher indices)
                const newSelected = new Set();
                selectedObjects.forEach(i => {
                    if (i < index) newSelected.add(i);
                    else if (i > index) newSelected.add(i - 1);
                    // Skip if i === index (deleted)
                });
                selectedObjects = newSelected;
                updateObjectList(currentMesh);
                updateSelectionCount();
                showStatus('Object deleted', 'success');
            }
        }

        // Add label
        function addLabel() {
            const text = document.getElementById('label-text').value;
            if (!text) {
                showStatus('Please enter label text', 'error');
                return;
            }

            // Create text sprite
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;

            context.fillStyle = 'rgba(0,0,0,0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);

            context.font = '48px Arial';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.fillText(text, canvas.width / 2, canvas.height / 2 + 16);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(50, 12.5, 1);
            sprite.position.set(0, 50, 0);

            sprite.userData = { type: 'label', id: 'label_' + Date.now() };
            scene.add(sprite);
            objectsList.push({ type: 'label', id: sprite.userData.id, name: text, object: sprite });

            document.getElementById('label-text').value = '';
            updateObjectList(currentMesh);
            showStatus('Label added!', 'success');
        }

        // Build export mesh data from current scene (respects deletions)
        function buildExportMesh() {
            const exportData = {
                terrain: null,
                features: [],
                gpx_track: null
            };

            objectsList.forEach(obj => {
                if (!obj.object || !obj.object.geometry) return;

                const geometry = obj.object.geometry;
                const position = geometry.attributes.position;
                const index = geometry.index;

                // Extract vertices
                const vertices = [];
                for (let i = 0; i < position.count; i++) {
                    vertices.push([
                        position.getX(i),
                        position.getY(i),
                        position.getZ(i)
                    ]);
                }

                // Extract faces
                const faces = [];
                if (index) {
                    for (let i = 0; i < index.count; i += 3) {
                        faces.push([
                            index.getX(i),
                            index.getX(i + 1),
                            index.getX(i + 2)
                        ]);
                    }
                }

                const meshData = {
                    vertices: vertices,
                    faces: faces,
                    type: obj.object.userData.type || obj.type,
                    id: obj.id,
                    name: obj.name,
                    is_address_building: obj.object.userData.isAddressBuilding || false
                };

                if (obj.type === 'Terrain' || obj.object.userData.type === 'terrain') {
                    exportData.terrain = meshData;
                } else if (obj.type === 'GPX' || obj.object.userData.type === 'gpx_track') {
                    exportData.gpx_track = meshData;
                } else if (obj.type !== 'marker' && obj.type !== 'label') {
                    exportData.features.push(meshData);
                }
            });

            return exportData;
        }

        // Export to 3MF (multi-object format for 3D printing)
        async function export3MF() {
            if (objectsList.length === 0) {
                showStatus('Please generate a model first', 'error');
                return;
            }

            try {
                showLoading(true);
                showStatus('Exporting to 3MF...', 'info');

                // Build mesh data from current scene (respects deletions)
                const exportMesh = buildExportMesh();

                const response = await fetch('/api/export/3mf', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        mesh: exportMesh,
                        filename: 'topo_model.3mf'
                    })
                });

                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'topo_model.3mf';
                    a.click();
                    window.URL.revokeObjectURL(url);

                    showStatus('3MF exported! Objects: Terrain, Roads, Buildings, GPX Track', 'success');
                } else {
                    const result = await response.json();
                    showStatus('Error: ' + result.error, 'error');
                }
            } catch (error) {
                showStatus('Error exporting 3MF: ' + error.message, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Store geocoded location for later use
        let geocodedLocation = null;

        // Set manual coordinates (from Google Maps)
        function setManualCoordinates() {
            const latStr = document.getElementById('lat-input').value.trim();
            const lonStr = document.getElementById('lon-input').value.trim();

            if (!latStr || !lonStr) {
                showStatus('Please enter both latitude and longitude', 'error');
                return;
            }

            const lat = parseFloat(latStr);
            const lon = parseFloat(lonStr);

            if (isNaN(lat) || isNaN(lon)) {
                showStatus('Invalid coordinates. Use decimal format (e.g., -37.847086, 140.787177)', 'error');
                return;
            }

            if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                showStatus('Coordinates out of range', 'error');
                return;
            }

            // Store location and create marker
            geocodedLocation = { lat, lon };
            createMarker(lat, lon);

            // Enable the "show only address building" checkbox
            document.getElementById('show-only-address-building').disabled = false;
            document.getElementById('address-status').textContent = `Manual coordinates: ${lat.toFixed(6)}, ${lon.toFixed(6)}`;

            showStatus(`Coordinates set: ${lat.toFixed(6)}, ${lon.toFixed(6)}`, 'success');
        }

        // Create marker for geocoded address
        function createMarker(lat, lon) {
            // Remove any existing marker
            const existingMarker = scene.children.find(obj => obj.userData && obj.userData.id === 'address_marker');
            if (existingMarker) {
                scene.remove(existingMarker);
                objectsList = objectsList.filter(obj => obj.id !== 'address_marker');
            }

            // Store location for later use when model is generated
            geocodedLocation = { lat, lon };

            // Create a taller cone marker (more visible)
            const geometry = new THREE.ConeGeometry(3, 8, 8);
            const material = new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x880000 });
            const marker = new THREE.Mesh(geometry, material);

            // Position relative to bounds using same math as mesh generator
            if (elevationData && currentMesh) {
                const bounds = elevationData.bounds;
                const modelWidth = parseFloat(document.getElementById('model-width').value) || 200;
                const latRange = bounds.north - bounds.south;
                const lonRange = bounds.east - bounds.west;
                const avgLat = (bounds.north + bounds.south) / 2;
                const lonScale = Math.cos(avgLat * Math.PI / 180);
                const scaleFactor = modelWidth / Math.max(latRange, lonRange * lonScale);

                const x = (lon - bounds.west) * scaleFactor * lonScale;
                const z = (bounds.north - lat) * scaleFactor;  // Flipped for map orientation

                // Get approximate Y from terrain height + offset
                const terrainHeight = 30;  // Approximate mid-height
                marker.position.set(x, terrainHeight + 10, z);
                marker.rotation.x = Math.PI;  // Point cone downward

                marker.userData = { type: 'marker', id: 'address_marker' };
                scene.add(marker);
                objectsList.push({ type: 'marker', id: 'address_marker', name: 'Address Marker', object: marker });
                updateObjectList(currentMesh);
            } else {
                // No GPX uploaded yet - place marker at center of scene and notify user
                marker.position.set(0, 20, 0);
                marker.userData = { type: 'marker', id: 'address_marker', pendingPosition: true };
                scene.add(marker);
                objectsList.push({ type: 'marker', id: 'address_marker', name: 'Address Marker (pending)', object: marker });
                updateObjectList(currentMesh);
                showStatus('Address saved! Upload a GPX file to position the marker on the terrain.', 'info');
            }
        }

        // UI helpers
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('status-message');
            statusEl.textContent = message;
            statusEl.className = `status status-floating ${type}`;
            statusEl.style.display = 'block';
            updateRenderDiagnostics(null, `status=${type}`);

            if (statusHideTimer) {
                clearTimeout(statusHideTimer);
            }
            statusHideTimer = setTimeout(() => {
                statusEl.style.display = 'none';
            }, 10000);
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('active', show);
        }

        function updateSliderValue(id) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + '-value');
            valueDisplay.textContent = slider.value;

            // If boundary padding changed and we have GPX data, update bounds and flag for refetch
            if (id === 'boundary-padding' && originalBounds && gpxData) {
                gpxData.bounds = getPaddedBounds(originalBounds);
                gpxData.needsRefetch = true;
            }
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            initScene();
        });
    </script>
</body>
</html>
